import{_ as i,c as a,a as e,o as n}from"./app-CFfGH9u5.js";const t={};function h(l,s){return n(),a("div",null,[...s[0]||(s[0]=[e(`<h2 id="引言" tabindex="-1"><a class="header-anchor" href="#引言"><span>引言</span></a></h2><p>在 CTF 竞赛的 Web 安全赛道上，有一个漏洞类型常年占据&quot;常驻嘉宾&quot;席位——PHP 环境下的 MD5 函数漏洞。无论是新手入门的基础题，还是进阶挑战的综合题，总能看到它的身影。这背后究竟藏着怎样的原因？</p><p><strong>数据透视</strong>：CTF 比赛中 Web 题型占比常年超 40%，而哈希相关题目在其中占比达 15%，PHP MD5 漏洞正是这部分题目的核心考点之一。这种高频出现的特性，让它成为每位 CTF 选手必须攻克的&quot;基本功&quot;。</p><p>MD5 作为曾经广泛使用的密码散列函数，设计初衷是验证数据完整性，而非保障安全性。随着安全技术发展，其缺陷逐渐暴露：不仅存在碰撞攻击风险（不同输入可能生成相同哈希值），弱密码还容易被彩虹表破解[<a href="https://www.oryoy.com/news/po-jie-php-mi-ma-jia-mi-md5-bei-hou-de-an-quan-feng-xian-yu-fang-hu-zhi-dao.html" target="_blank" rel="noopener noreferrer">1</a>]。但在 CTF 赛场，真正让它&quot;长盛不衰&quot;的，是 PHP 语言对 MD5 函数的特殊处理机制。</p><p>PHP 的弱类型比较规则（如 <code>==</code> 运算符对不同类型数据的宽松比较）、数组处理缺陷（将数组传入 MD5 函数返回 <code>NULL</code>），以及对哈希值的特殊解析逻辑，共同构成了丰富的漏洞场景[<a href="https://blog.csdn.net/thinszx/article/details/104737320" target="_blank" rel="noopener noreferrer">2</a>][<a href="https://blog.csdn.net/reme_mber/article/details/124235010" target="_blank" rel="noopener noreferrer">3</a>]。攻击者可利用这些特性，通过构造特殊输入绕过登录验证、突破权限检查，甚至实现 SQL 注入等攻击[<a href="https://blog.csdn.net/Jeff_12138/article/details/121847582" target="_blank" rel="noopener noreferrer">4</a>]。</p><p>从简单的 <code>==</code> 弱比较绕过，到复杂的哈希碰撞利用，PHP MD5 漏洞既考察选手对语言特性的理解深度，又检验实战中的漏洞挖掘能力。接下来，我们将深入剖析这些漏洞的底层原理，拆解经典解题思路，助你在 CTF 赛场快速突破这类高频考点。</p><h2 id="核心知识点详解" tabindex="-1"><a class="header-anchor" href="#核心知识点详解"><span>核心知识点详解</span></a></h2><p>在CTF竞赛中，PHP的MD5函数漏洞是常见的突破口。这些漏洞并非MD5算法本身的碰撞问题，而是PHP语言特性与函数实现细节共同造就的&quot;陷阱&quot;。下面从三个核心维度解析其原理与实战场景。</p><h3 id="弱类型比较漏洞-0e开头的-数字魔术" tabindex="-1"><a class="header-anchor" href="#弱类型比较漏洞-0e开头的-数字魔术"><span>弱类型比较漏洞：0e开头的&quot;数字魔术&quot;</span></a></h3><p><strong>原理说明</strong> PHP在使用<code>==</code>进行弱类型比较时，会将字符串转换为数值后再比较。若字符串以<code>0e</code>开头且后续字符均为数字，会被解析为科学计数法表示的<code>0</code>（如<code>0e123</code>等价于<code>0×10^123=0</code>）。因此，两个不同字符串若MD5哈希值均满足<code>0e</code>开头的数字格式，在弱比较中会被判定为相等[<a href="https://blog.csdn.net/jblock/article/details/88534588" target="_blank" rel="noopener noreferrer">5</a>][<a href="https://blog.51cto.com/u_15854462/11803182" target="_blank" rel="noopener noreferrer">6</a>]。</p><p><strong>代码演示</strong> 以下代码中，两个不同的输入字符串通过MD5哈希后，弱比较结果为<code>true</code>：</p><div class="language-php line-numbers-mode" data-highlighter="shiki" data-ext="php" style="--shiki-light:#000000;--shiki-dark:#bfbdb6;--shiki-light-bg:#FFFFFF;--shiki-dark-bg:#0b0e14;"><pre class="shiki shiki-themes light-plus ayu-dark vp-code"><code class="language-php"><span class="line"><span style="--shiki-light:#000000;--shiki-dark:#F29668;">&lt;?</span><span style="--shiki-light:#000000;--shiki-dark:#95E6CB;">php</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#BFBDB6;">$a</span><span style="--shiki-light:#000000;--shiki-dark:#F29668;"> =</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;"> &#39;QNKCDZO&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6B3;">;</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#BFBDB6;">$b</span><span style="--shiki-light:#000000;--shiki-dark:#F29668;"> =</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;"> &#39;240610708&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6B3;">;</span></span>
<span class="line"><span style="--shiki-light:#795E26;--shiki-dark:#F07178;">var_dump</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">(</span><span style="--shiki-light:#795E26;--shiki-dark:#F07178;">md5</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">(</span><span style="--shiki-light:#001080;--shiki-dark:#BFBDB6;">$a</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">) </span><span style="--shiki-light:#000000;--shiki-dark:#F29668;">==</span><span style="--shiki-light:#795E26;--shiki-dark:#F07178;"> md5</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">(</span><span style="--shiki-light:#001080;--shiki-dark:#BFBDB6;">$b</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">))</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6B3;">;</span><span style="--shiki-light:#008000;--shiki-light-font-style:inherit;--shiki-dark:#ACB6BF8C;--shiki-dark-font-style:italic;"> // 输出 bool(true)</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-light-font-style:inherit;--shiki-dark:#ACB6BF8C;--shiki-dark-font-style:italic;">// md5($a) = 0e830400451993494058024219903391</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-light-font-style:inherit;--shiki-dark:#ACB6BF8C;--shiki-dark-font-style:italic;">// md5($b) = 0e462097431906509019562988736854</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#F29668;">?&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>漏洞本质</strong> PHP的类型转换机制将特定格式的哈希字符串误判为数值<code>0</code>，导致逻辑上的哈希碰撞。这种&quot;伪碰撞&quot;无需实现真正的MD5算法碰撞，仅需利用字符串解析规则即可绕过验证。</p><p><strong>常见0e开头MD5值对照表</strong></p><table><thead><tr><th>原始字符串</th><th>MD5哈希值（32位十六进制）</th></tr></thead><tbody><tr><td>QNKCDZO</td><td>0e830400451993494058024219903391</td></tr><tr><td>240610708</td><td>0e462097431906509019562988736854</td></tr><tr><td>s878926199a</td><td>0e545993274517709034328855841020</td></tr><tr><td>s155964671a</td><td>0e342768416822451524974117254469</td></tr></tbody></table><h3 id="数组绕过-null值的-意外相等" tabindex="-1"><a class="header-anchor" href="#数组绕过-null值的-意外相等"><span>数组绕过：NULL值的&quot;意外相等&quot;</span></a></h3><p><strong>原理说明</strong> PHP的<code>md5()</code>函数仅接受字符串输入，当传入数组时会返回<code>NULL</code>。因此，两个不同的数组参数经过<code>md5()</code>处理后结果均为<code>NULL</code>，在强类型比较（<code>===</code>）中会被判定为相等[<a href="https://blog.csdn.net/qq_19980431/article/details/83018856" target="_blank" rel="noopener noreferrer">7</a>][<a href="https://www.cnblogs.com/tazmi/p/18535665" target="_blank" rel="noopener noreferrer">8</a>]。</p><p><strong>代码演示</strong> 以下场景中，通过传入数组参数可绕过强比较验证：</p><div class="language-php line-numbers-mode" data-highlighter="shiki" data-ext="php" style="--shiki-light:#000000;--shiki-dark:#bfbdb6;--shiki-light-bg:#FFFFFF;--shiki-dark-bg:#0b0e14;"><pre class="shiki shiki-themes light-plus ayu-dark has-diff vp-code"><code class="language-php"><span class="line"><span style="--shiki-light:#000000;--shiki-dark:#F29668;">&lt;?</span><span style="--shiki-light:#000000;--shiki-dark:#95E6CB;">php</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-light-font-style:inherit;--shiki-dark:#ACB6BF8C;--shiki-dark-font-style:italic;">// 目标代码：要求a和b不同，但MD5值强相等</span></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#FF8F40;">if</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;"> (</span><span style="--shiki-light:#795E26;--shiki-dark:#F07178;">md5</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">(</span><span style="--shiki-light:#001080;--shiki-dark:#BFBDB6;">$_GET</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">[</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;">&#39;a&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">]) </span><span style="--shiki-light:#000000;--shiki-dark:#F29668;">===</span><span style="--shiki-light:#795E26;--shiki-dark:#F07178;"> md5</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">(</span><span style="--shiki-light:#001080;--shiki-dark:#BFBDB6;">$_GET</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">[</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;">&#39;b&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">]) </span><span style="--shiki-light:#000000;--shiki-dark:#F29668;">&amp;&amp;</span><span style="--shiki-light:#001080;--shiki-dark:#BFBDB6;"> $_GET</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">[</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;">&#39;a&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">] </span><span style="--shiki-light:#000000;--shiki-dark:#F29668;">!==</span><span style="--shiki-light:#001080;--shiki-dark:#BFBDB6;"> $_GET</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">[</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;">&#39;b&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">]) {</span></span>
<span class="line"><span style="--shiki-light:#795E26;--shiki-dark:#F07178;">echo</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;"> &quot;Flag: CTF{...}&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6B3;">;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">}</span></span>
<span class="line diff add"><span style="--shiki-light:#008000;--shiki-light-font-style:inherit;--shiki-dark:#ACB6BF8C;--shiki-dark-font-style:italic;"># 利用Payload：?a[]=1&amp;b[]=2</span></span>
<span class="line diff add"><span style="--shiki-light:#008000;--shiki-light-font-style:inherit;--shiki-dark:#ACB6BF8C;--shiki-dark-font-style:italic;"># md5($_GET[&#39;a&#39;]) = NULL，md5($_GET[&#39;b&#39;]) = NULL，且a和b为不同数组</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#F29668;">?&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>漏洞本质</strong><code>md5()</code>函数对数组类型的错误处理（返回<code>NULL</code>而非抛出异常），使得攻击者可通过构造不同数组参数，让强比较条件恒成立。这种绕过无需依赖哈希值本身，直接利用函数参数类型缺陷。</p><h3 id="二进制注入-从哈希值到sql永真条件" tabindex="-1"><a class="header-anchor" href="#二进制注入-从哈希值到sql永真条件"><span>二进制注入：从哈希值到SQL永真条件</span></a></h3><p><strong>原理说明</strong> 当<code>md5()</code>函数第二个参数为<code>true</code>时，返回16字节原始二进制数据而非32位十六进制字符串。若二进制数据中包含SQL特殊字符（如单引号、<code>OR</code>关键字），直接拼接进SQL语句会导致注入漏洞[<a href="https://blog.csdn.net/bin789456/article/details/119977456" target="_blank" rel="noopener noreferrer">9</a>][<a href="https://cloud.tencent.cn/developer/article/2357273?areaId=106001" target="_blank" rel="noopener noreferrer">10</a>]。</p><p><strong>代码演示</strong> 经典利用字符串<code>ffifdyop</code>的MD5原始输出可构造永真条件：</p><div class="language-php line-numbers-mode" data-highlighter="shiki" data-ext="php" style="--shiki-light:#000000;--shiki-dark:#bfbdb6;--shiki-light-bg:#FFFFFF;--shiki-dark-bg:#0b0e14;"><pre class="shiki shiki-themes light-plus ayu-dark vp-code"><code class="language-php"><span class="line"><span style="--shiki-light:#000000;--shiki-dark:#F29668;">&lt;?</span><span style="--shiki-light:#000000;--shiki-dark:#95E6CB;">php</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-light-font-style:inherit;--shiki-dark:#ACB6BF8C;--shiki-dark-font-style:italic;">// 漏洞代码：直接拼接MD5二进制结果到SQL</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#BFBDB6;">$pass</span><span style="--shiki-light:#000000;--shiki-dark:#F29668;"> =</span><span style="--shiki-light:#001080;--shiki-dark:#BFBDB6;"> $_GET</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">[</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;">&#39;pass&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">]</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6B3;">;</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#BFBDB6;">$sql</span><span style="--shiki-light:#000000;--shiki-dark:#F29668;"> =</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;"> &quot;</span><span style="--shiki-light:#0000FF;--shiki-dark:#FF8F40;">SELECT</span><span style="--shiki-light:#000000;--shiki-dark:#F29668;"> *</span><span style="--shiki-light:#0000FF;--shiki-dark:#FF8F40;"> FROM</span><span style="--shiki-light:#0000FF;--shiki-dark:#FF8F40;"> admin</span><span style="--shiki-light:#0000FF;--shiki-dark:#FF8F40;"> WHERE</span><span style="--shiki-light:#0000FF;--shiki-dark:#FF8F40;"> password</span><span style="--shiki-light:#000000;--shiki-dark:#F29668;"> =</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;"> &#39;&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#F29668;"> .</span><span style="--shiki-light:#795E26;--shiki-dark:#F07178;"> md5</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">(</span><span style="--shiki-light:#001080;--shiki-dark:#BFBDB6;">$pass</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6B3;">,</span><span style="--shiki-light:#0000FF;--shiki-dark:#D2A6FF;"> true</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">) </span><span style="--shiki-light:#000000;--shiki-dark:#F29668;">.</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;"> &quot;&#39;&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6B3;">;</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-light-font-style:inherit;--shiki-dark:#ACB6BF8C;--shiki-dark-font-style:italic;">// 当$pass = &#39;ffifdyop&#39;时：</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-light-font-style:inherit;--shiki-dark:#ACB6BF8C;--shiki-dark-font-style:italic;">// md5(&#39;ffifdyop&#39;, true)的十六进制为：276f722736c95d99e921722cf9ed621c</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-light-font-style:inherit;--shiki-dark:#ACB6BF8C;--shiki-dark-font-style:italic;">// 转换为ASCII字符串：&#39;or&#39;6�]��!r,��b�</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-light-font-style:inherit;--shiki-dark:#ACB6BF8C;--shiki-dark-font-style:italic;">// 拼接后SQL变为：SELECT * FROM admin WHERE password = &#39;&#39;or&#39;6xxx&#39;</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-light-font-style:inherit;--shiki-dark:#ACB6BF8C;--shiki-dark-font-style:italic;">// 其中 &#39;&#39;or&#39;6xxx 等价于 1=1，形成永真条件</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#F29668;">?&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>关键转换过程</strong>：<code>ffifdyop</code>的MD5原始二进制数据前4字节为<code>0x27 0x6f 0x72 0x27</code>，对应ASCII字符为<code>&#39;or&#39;</code>，恰好闭合SQL语句中的单引号并注入<code>OR</code>逻辑，导致查询条件恒真。</p><p><strong>漏洞本质</strong> 二进制哈希值中的特殊字符破坏了SQL语句结构，将密码验证逻辑转化为永真条件。这种漏洞结合了哈希函数的原始输出特性与SQL注入的语法缺陷，是典型的&quot;特性叠加漏洞&quot;。</p><p>以上三种漏洞均源于PHP的设计特性而非MD5算法本身，在CTF中需根据代码中的比较方式（<code>==</code>/<code>===</code>）、参数类型（字符串/数组）、哈希输出格式（十六进制/二进制）灵活选择绕过策略。理解这些底层原理，不仅能快速破解题目，更能在实际开发中规避类似风险。</p><h3 id="常见绕过技巧" tabindex="-1"><a class="header-anchor" href="#常见绕过技巧"><span>常见绕过技巧</span></a></h3><h4 id="_0e弱比较绕过" tabindex="-1"><a class="header-anchor" href="#_0e弱比较绕过"><span>0e弱比较绕过</span></a></h4><p><strong>技巧类型</strong>：利用PHP弱类型比较特性的魔术哈希攻击 <strong>适用场景</strong>：代码中使用<code>==</code>进行MD5值比较（如<code>md5($a) == md5($b)</code>），且需满足<code>$a != $b</code>的条件。</p><p><strong>Payload构造</strong>： 核心是寻找MD5哈希值以<code>0e</code>开头且后续字符均为数字的字符串（魔术哈希）。这类哈希值在PHP中会被解析为科学计数法<code>0</code>，导致不同字符串的MD5值在弱比较中被判定为相等。以下是CTF中常用的魔术哈希字符串列表：</p><table><thead><tr><th>原始字符串</th><th>MD5哈希值</th></tr></thead><tbody><tr><td>QNKCDZO</td><td>0e830400451993494058024219903391</td></tr><tr><td>240610708</td><td>0e462097431906509019562988736854</td></tr><tr><td>s878926199a</td><td>0e545993274517709034328855841020</td></tr><tr><td>s155964671a</td><td>0e342768416822451524974117254469</td></tr><tr><td>s214587387a</td><td>0e848240448830537924465865611904</td></tr><tr><td>s1091221200a</td><td>0e940624217856561557816327384675</td></tr></tbody></table><p><strong>原理验证</strong>： PHP在处理<code>==</code>比较时会对操作数进行类型转换。当哈希值以<code>0e</code>开头且后续为纯数字时，会被识别为科学计数法<code>0</code>，例如：</p><div class="language-php line-numbers-mode" data-highlighter="shiki" data-ext="php" style="--shiki-light:#000000;--shiki-dark:#bfbdb6;--shiki-light-bg:#FFFFFF;--shiki-dark-bg:#0b0e14;"><pre class="shiki shiki-themes light-plus ayu-dark vp-code"><code class="language-php"><span class="line"><span style="--shiki-light:#795E26;--shiki-dark:#F07178;">var_dump</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">(</span><span style="--shiki-light:#795E26;--shiki-dark:#F07178;">md5</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">(</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;">&quot;QNKCDZO&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">) </span><span style="--shiki-light:#000000;--shiki-dark:#F29668;">==</span><span style="--shiki-light:#795E26;--shiki-dark:#F07178;"> md5</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">(</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;">&quot;240610708&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">))</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6B3;">;</span><span style="--shiki-light:#008000;--shiki-light-font-style:inherit;--shiki-dark:#ACB6BF8C;--shiki-dark-font-style:italic;"> // 输出 bool(true)</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-light-font-style:inherit;--shiki-dark:#ACB6BF8C;--shiki-dark-font-style:italic;">// 实际哈希值均为0e开头，被转换为0后比较相等</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意</strong>：该技巧仅适用于弱比较（<code>==</code>），强比较（<code>===</code>）中<code>0e</code>哈希值不会被转换，需使用其他方法绕过。</p><h4 id="数组传递绕过" tabindex="-1"><a class="header-anchor" href="#数组传递绕过"><span>数组传递绕过</span></a></h4><p><strong>技巧类型</strong>：利用PHP数组类型处理缺陷的参数注入 <strong>适用场景</strong>：代码中要求<code>md5($a) === md5($b)</code>且<code>$a !== $b</code>（强比较场景），或<code>md5($a) == md5($b)</code>（弱比较场景）。</p><p><strong>Payload构造</strong>： 向MD5函数传递数组参数，PHP的<code>md5()</code>函数处理数组时会返回<code>NULL</code>。因此，构造两个不同的数组参数，可使它们的MD5值均为<code>NULL</code>，从而满足比较条件。</p><ul><li><strong>GET传参</strong>：通过URL参数传递数组，格式为<code>?参数名[]=值</code> 示例：<code>?a[]=1&amp;b[]=2</code>（此时<code>$a = [1]</code>，<code>$b = [2]</code>，均为数组）</li><li><strong>POST传参</strong>：在表单或请求体中传递数组，格式为<code>参数名[]=值</code> 示例：<code>a[]=x&amp;b[]=y</code>（表单字段或JSON键值对）</li></ul><p><strong>原理验证</strong>： PHP中<code>md5()</code>函数接收非字符串类型参数时返回<code>NULL</code>，因此不同数组的MD5值均为<code>NULL</code>：</p><div class="language-php line-numbers-mode" data-highlighter="shiki" data-ext="php" style="--shiki-light:#000000;--shiki-dark:#bfbdb6;--shiki-light-bg:#FFFFFF;--shiki-dark-bg:#0b0e14;"><pre class="shiki shiki-themes light-plus ayu-dark vp-code"><code class="language-php"><span class="line"><span style="--shiki-light:#795E26;--shiki-dark:#F07178;">var_dump</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">(</span><span style="--shiki-light:#795E26;--shiki-dark:#F07178;">md5</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">([</span><span style="--shiki-light:#098658;--shiki-dark:#D2A6FF;">1</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">]) </span><span style="--shiki-light:#000000;--shiki-dark:#F29668;">===</span><span style="--shiki-light:#795E26;--shiki-dark:#F07178;"> md5</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">([</span><span style="--shiki-light:#098658;--shiki-dark:#D2A6FF;">2</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">]))</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6B3;">;</span><span style="--shiki-light:#008000;--shiki-light-font-style:inherit;--shiki-dark:#ACB6BF8C;--shiki-dark-font-style:italic;"> // 输出 bool(true)</span></span>
<span class="line"><span style="--shiki-light:#795E26;--shiki-dark:#F07178;">var_dump</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">([</span><span style="--shiki-light:#098658;--shiki-dark:#D2A6FF;">1</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">] </span><span style="--shiki-light:#000000;--shiki-dark:#F29668;">!==</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;"> [</span><span style="--shiki-light:#098658;--shiki-dark:#D2A6FF;">2</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">])</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6B3;">;</span><span style="--shiki-light:#008000;--shiki-light-font-style:inherit;--shiki-dark:#ACB6BF8C;--shiki-dark-font-style:italic;"> // 输出 bool(true)，满足参数不同的条件</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="哈希碰撞绕过" tabindex="-1"><a class="header-anchor" href="#哈希碰撞绕过"><span>哈希碰撞绕过</span></a></h4><p><strong>技巧类型</strong>：利用MD5算法碰撞特性的二进制文件注入 <strong>适用场景</strong>：代码中使用强比较（<code>===</code>）验证MD5值，且无法通过数组绕过（如限制参数为字符串类型）。</p><p><strong>Payload构造</strong>： 使用专业工具（如<code>fastcoll</code>）生成两个内容不同但MD5哈希值完全相同的二进制文件，URL编码后作为参数传入。</p><ol><li><p><strong>工具使用步骤</strong>：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#000000;--shiki-dark:#bfbdb6;--shiki-light-bg:#FFFFFF;--shiki-dark-bg:#0b0e14;"><pre class="shiki shiki-themes light-plus ayu-dark vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#008000;--shiki-light-font-style:inherit;--shiki-dark:#ACB6BF8C;--shiki-dark-font-style:italic;"># 安装fastcoll（Windows/Linux版本需对应系统）</span></span>
<span class="line"><span style="--shiki-light:#795E26;--shiki-dark:#59C2FF;">fastcoll_v1.0.0.5.exe</span><span style="--shiki-light:#0000FF;--shiki-dark:#95E6CB;"> -p</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;"> 源文件.bin</span><span style="--shiki-light:#0000FF;--shiki-dark:#95E6CB;"> -o</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;"> 碰撞文件1.bin</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;"> 碰撞文件2.bin</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-light-font-style:inherit;--shiki-dark:#ACB6BF8C;--shiki-dark-font-style:italic;"># 生成两个MD5相同的文件：碰撞文件1.bin 和 碰撞文件2.bin</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>MD5值对比</strong>： 生成的两个文件内容差异通常仅为1-2字节，但MD5值完全一致：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#000000;--shiki-dark:#bfbdb6;--shiki-light-bg:#FFFFFF;--shiki-dark-bg:#0b0e14;"><pre class="shiki shiki-themes light-plus ayu-dark vp-code"><code class="language-"><span class="line"><span>碰撞文件1.bin MD5: 4dc968ff0ee35c209572d4777b721587d36fa7b21bdc56b74a3dc0783e7b9518afbfa200a8284bf36e8e4b55b35f427593d849676da0d1555d8360fb5f07fea2</span></span>
<span class="line"><span>碰撞文件2.bin MD5: 4dc968ff0ee35c209572d4777b721587d36fa7b21bdc56b74a3dc0783e7b9518afbfa202a8284bf36e8e4b55b35f427593d849676da0d1d55d8360fb5f07fea2</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>CTF应用</strong>： 将二进制文件内容通过PHP脚本转换为URL编码字符串，作为参数传入。例如：</p><div class="language-php line-numbers-mode" data-highlighter="shiki" data-ext="php" style="--shiki-light:#000000;--shiki-dark:#bfbdb6;--shiki-light-bg:#FFFFFF;--shiki-dark-bg:#0b0e14;"><pre class="shiki shiki-themes light-plus ayu-dark vp-code"><code class="language-php"><span class="line"><span style="--shiki-light:#008000;--shiki-light-font-style:inherit;--shiki-dark:#ACB6BF8C;--shiki-dark-font-style:italic;">// 读取碰撞文件内容并URL编码</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#BFBDB6;">$payload1</span><span style="--shiki-light:#000000;--shiki-dark:#F29668;"> =</span><span style="--shiki-light:#795E26;--shiki-dark:#F07178;"> urlencode</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">(</span><span style="--shiki-light:#795E26;--shiki-dark:#F07178;">file_get_contents</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">(</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;">&#39;碰撞文件1.bin&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">))</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6B3;">;</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#BFBDB6;">$payload2</span><span style="--shiki-light:#000000;--shiki-dark:#F29668;"> =</span><span style="--shiki-light:#795E26;--shiki-dark:#F07178;"> urlencode</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">(</span><span style="--shiki-light:#795E26;--shiki-dark:#F07178;">file_get_contents</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">(</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;">&#39;碰撞文件2.bin&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">))</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6B3;">;</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-light-font-style:inherit;--shiki-dark:#ACB6BF8C;--shiki-dark-font-style:italic;">// 结果作为GET参数：?a=$payload1&amp;b=$payload2</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><p><strong>原理验证</strong>： MD5算法存在碰撞漏洞，可通过工具生成哈希值相同的不同文件。URL编码后，二进制内容被转换为字符串参数，服务器接收后解码为原始二进制，其MD5值仍保持一致，从而绕过强比较验证。</p><p><strong>实战技巧</strong>：生成的碰撞文件通常较大（约128KB），需注意CTF题目是否限制参数长度。若长度受限，可尝试使用精简版碰撞字符串（如16字节差异的短碰撞）。</p><h2 id="典型题目解析" tabindex="-1"><a class="header-anchor" href="#典型题目解析"><span>典型题目解析</span></a></h2><h3 id="ctfshow-web9-二进制原始输出注入" tabindex="-1"><a class="header-anchor" href="#ctfshow-web9-二进制原始输出注入"><span>CTFshow-web9：二进制原始输出注入</span></a></h3><h4 id="代码审计-定位md5处理逻辑" tabindex="-1"><a class="header-anchor" href="#代码审计-定位md5处理逻辑"><span>代码审计：定位MD5处理逻辑</span></a></h4><p>CTFshow-web9的核心漏洞隐藏在MD5函数的特殊用法中。题目源代码如下，关键在于<code>md5($pass, true)</code>的处理逻辑：</p><div class="language-php line-numbers-mode" data-highlighter="shiki" data-ext="php" style="--shiki-light:#000000;--shiki-dark:#bfbdb6;--shiki-light-bg:#FFFFFF;--shiki-dark-bg:#0b0e14;"><pre class="shiki shiki-themes light-plus ayu-dark vp-code"><code class="language-php"><span class="line"><span style="--shiki-light:#008000;--shiki-light-font-style:inherit;--shiki-dark:#ACB6BF8C;--shiki-dark-font-style:italic;">// index.phps</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#F29668;">&lt;?</span><span style="--shiki-light:#000000;--shiki-dark:#95E6CB;">php</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#BFBDB6;">$pass</span><span style="--shiki-light:#000000;--shiki-dark:#F29668;"> =</span><span style="--shiki-light:#001080;--shiki-dark:#BFBDB6;"> $_GET</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">[</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;">&#39;pass&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">]</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6B3;">;</span></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#FF8F40;">if</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">(</span><span style="--shiki-light:#795E26;--shiki-dark:#F07178;">md5</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">(</span><span style="--shiki-light:#001080;--shiki-dark:#BFBDB6;">$pass</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6B3;">,</span><span style="--shiki-light:#0000FF;--shiki-dark:#D2A6FF;"> true</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">) </span><span style="--shiki-light:#000000;--shiki-dark:#F29668;">===</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;"> &quot;&#39;or&#39;6xxx&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">){</span></span>
<span class="line"><span style="--shiki-light:#795E26;--shiki-dark:#F07178;">echo</span><span style="--shiki-light:#001080;--shiki-dark:#BFBDB6;"> $flag</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6B3;">;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">}</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#F29668;">?&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码通过<code>md5($pass, true)</code>将用户输入的<code>pass</code>参数转换为<strong>原始二进制输出</strong>，并与字符串<code>&#39;or&#39;6xxx</code>进行比较。若完全匹配则输出flag。这里的关键在于<code>md5</code>函数的第二个参数<code>true</code>——当该参数为真时，函数返回<strong>16字节原始二进制数据</strong>而非32位十六进制字符串，这为SQL注入攻击提供了可能性[<a href="https://github.com/seunghunoh57/SQL-Injection" target="_blank" rel="noopener noreferrer">11</a>]。</p><h4 id="漏洞点分析-二进制输出的特殊字符风险" tabindex="-1"><a class="header-anchor" href="#漏洞点分析-二进制输出的特殊字符风险"><span>漏洞点分析：二进制输出的特殊字符风险</span></a></h4><p>PHP中<code>md5($str, true)</code>的原始二进制输出可能包含单引号、等号等特殊字符。若这些字符被直接拼接到SQL语句中，可能破坏原有查询结构。例如，某题目中的SQL语句拼接逻辑如下：</p><div class="language-php line-numbers-mode" data-highlighter="shiki" data-ext="php" style="--shiki-light:#000000;--shiki-dark:#bfbdb6;--shiki-light-bg:#FFFFFF;--shiki-dark-bg:#0b0e14;"><pre class="shiki shiki-themes light-plus ayu-dark vp-code"><code class="language-php"><span class="line"><span style="--shiki-light:#001080;--shiki-dark:#BFBDB6;">$sql_s</span><span style="--shiki-light:#000000;--shiki-dark:#F29668;"> =</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;"> &quot;</span><span style="--shiki-light:#0000FF;--shiki-dark:#FF8F40;">SELECT</span><span style="--shiki-light:#000000;--shiki-dark:#F29668;"> *</span><span style="--shiki-light:#0000FF;--shiki-dark:#FF8F40;"> FROM</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;"> users </span><span style="--shiki-light:#0000FF;--shiki-dark:#FF8F40;">WHERE</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;"> username</span><span style="--shiki-light:#000000;--shiki-dark:#F29668;">=</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;">&#39;</span><span style="--shiki-light:#001080;--shiki-dark:#BFBDB6;">$username</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;">&#39; </span><span style="--shiki-light:#0000FF;--shiki-dark:#FF8F40;">and</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;"> pw</span><span style="--shiki-light:#000000;--shiki-dark:#F29668;">=</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;">&#39;</span><span style="--shiki-light:#001080;--shiki-dark:#BFBDB6;">$password</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;">&#39;&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6B3;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>当<code>$password</code>是<code>md5($pass, true)</code>的结果时，若二进制数据中包含<code>&#39; OR &#39;1&#39;=&#39;1</code>，则SQL语句会变为：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#000000;--shiki-dark:#bfbdb6;--shiki-light-bg:#FFFFFF;--shiki-dark-bg:#0b0e14;"><pre class="shiki shiki-themes light-plus ayu-dark vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#FF8F40;">SELECT</span><span style="--shiki-light:#000000;--shiki-dark:#F29668;"> *</span><span style="--shiki-light:#0000FF;--shiki-dark:#FF8F40;"> FROM</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;"> users </span><span style="--shiki-light:#0000FF;--shiki-dark:#FF8F40;">WHERE</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;"> username</span><span style="--shiki-light:#000000;--shiki-dark:#F29668;">=</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;">&#39;$username&#39;</span><span style="--shiki-light:#0000FF;--shiki-dark:#FF8F40;"> and</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;"> pw</span><span style="--shiki-light:#000000;--shiki-dark:#F29668;">=</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;">&#39;&#39;</span><span style="--shiki-light:#0000FF;--shiki-dark:#FF8F40;"> OR</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;"> &#39;1&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#F29668;">=</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;">&#39;1&#39;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>此时<code>OR &#39;1&#39;=&#39;1</code>构成永真条件，直接绕过认证[<a href="https://cloud.tencent.cn/developer/article/2357273?areaId=106001" target="_blank" rel="noopener noreferrer">10</a>]。</p><p><strong>核心原理</strong>：原始二进制输出中的特殊字符（如单引号、<code>OR</code>关键字）可构造SQL注入Payload，本质是利用哈希算法的输出特性篡改查询逻辑。</p><h4 id="payload构造-ffifdyop的妙用" tabindex="-1"><a class="header-anchor" href="#payload构造-ffifdyop的妙用"><span>Payload构造：ffifdyop的妙用</span></a></h4><p>针对本题，最经典的Payload是字符串<code>ffifdyop</code>。其<code>md5($pass, true)</code>的结果具有特殊结构：</p><ol><li><strong>MD5哈希值</strong>：<code>ffifdyop</code>的MD5原始二进制数据对应的十六进制为<code>276f722736c95d99e921722cf9ed621c</code>；</li><li><strong>ASCII转换</strong>：前4个字节<code>27 6f 72 27</code>对应ASCII字符<code>&#39; o r &#39;</code>，拼接后续字节后形成<code>&#39;or&#39;6xxx</code>结构（完整二进制转ASCII结果为<code>&#39;or&#39;6�]��!r,��b�</code>）[<a href="https://blog.csdn.net/jblock/article/details/88534588" target="_blank" rel="noopener noreferrer">5</a>]。</li></ol><p>当用户输入<code>pass=ffifdyop</code>时，<code>md5($pass, true)</code>的结果恰好满足<code>&#39;or&#39;6xxx</code>的匹配条件，直接输出flag。在实际SQL注入场景中，类似逻辑会使查询语句变为：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#000000;--shiki-dark:#bfbdb6;--shiki-light-bg:#FFFFFF;--shiki-dark-bg:#0b0e14;"><pre class="shiki shiki-themes light-plus ayu-dark vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#FF8F40;">SELECT</span><span style="--shiki-light:#000000;--shiki-dark:#F29668;"> *</span><span style="--shiki-light:#0000FF;--shiki-dark:#FF8F40;"> FROM</span><span style="--shiki-light:#0000FF;--shiki-dark:#FF8F40;"> admin</span><span style="--shiki-light:#0000FF;--shiki-dark:#FF8F40;"> WHERE</span><span style="--shiki-light:#0000FF;--shiki-dark:#FF8F40;"> password</span><span style="--shiki-light:#000000;--shiki-dark:#F29668;">=</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;">&#39;&#39;</span><span style="--shiki-light:#0000FF;--shiki-dark:#FF8F40;"> or</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;"> &#39;6xxxxx&#39;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>其中<code>&#39;or&#39;</code>关键字将条件分割为<code>password=&#39;&#39;</code>和<code>&#39;6xxxxx&#39;</code>，由于<code>&#39;6xxxxx&#39;</code>在SQL中被视为非空字符串（恒为真），整个条件恒成立，从而绕过认证[<a href="https://blog.csdn.net/qq_68581192/article/details/133792670" target="_blank" rel="noopener noreferrer">12</a>]。</p><h4 id="实战验证-burp提交与响应" tabindex="-1"><a class="header-anchor" href="#实战验证-burp提交与响应"><span>实战验证：Burp提交与响应</span></a></h4><p>在实战中，通过Burp Suite向目标URL提交<code>?pass=ffifdyop</code>，服务器端<code>md5($pass, true)</code>的结果会匹配<code>&#39;or&#39;6xxx</code>，直接返回flag。这一过程的关键在于理解<strong>原始二进制输出与字符串比较的特性</strong>——即使二进制数据中包含不可见字符（如<code>�</code>），只要前几位匹配<code>&#39;or&#39;6</code>，即可满足题目中的判断条件[<a href="https://blog.csdn.net/bin789456/article/details/119977456" target="_blank" rel="noopener noreferrer">9</a>]。</p><p><strong>利用步骤总结</strong>：</p><ol><li>构造输入字符串<code>ffifdyop</code>；</li><li>其MD5原始二进制输出包含<code>&#39;or&#39;6</code>结构；</li><li>触发<code>md5($pass, true) === &quot;&#39;or&#39;6xxx&quot;</code>条件，获取flag。</li></ol><p>这一漏洞揭示了“哈希函数输出安全处理”的重要性——即使是看似安全的MD5加密，若对原始二进制结果处理不当，也可能沦为注入攻击的突破口。</p><h3 id="bjdctf-2020-easy-md5-弱比较与数组绕过组合" tabindex="-1"><a class="header-anchor" href="#bjdctf-2020-easy-md5-弱比较与数组绕过组合"><span>BJDCTF 2020 Easy MD5：弱比较与数组绕过组合</span></a></h3><p>在 CTF 比赛中，MD5 漏洞常常以“看似矛盾”的验证逻辑出现，BJDCTF 2020 Easy MD5 就是典型案例。该题目通过两层验证机制，分别考察了 PHP 弱比较特性与数组处理缺陷，需要结合两种绕过技巧才能成功解题。</p><h4 id="第一层-0e-开头哈希值的弱比较绕过" tabindex="-1"><a class="header-anchor" href="#第一层-0e-开头哈希值的弱比较绕过"><span>第一层：0e 开头哈希值的弱比较绕过</span></a></h4><p>题目第一层验证逻辑如下：</p><div class="language-php line-numbers-mode" data-highlighter="shiki" data-ext="php" style="--shiki-light:#000000;--shiki-dark:#bfbdb6;--shiki-light-bg:#FFFFFF;--shiki-dark-bg:#0b0e14;"><pre class="shiki shiki-themes light-plus ayu-dark vp-code"><code class="language-php"><span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#FF8F40;">if</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">(</span><span style="--shiki-light:#001080;--shiki-dark:#BFBDB6;">$a</span><span style="--shiki-light:#000000;--shiki-dark:#F29668;"> !=</span><span style="--shiki-light:#001080;--shiki-dark:#BFBDB6;"> $b</span><span style="--shiki-light:#000000;--shiki-dark:#F29668;"> &amp;&amp;</span><span style="--shiki-light:#795E26;--shiki-dark:#F07178;"> md5</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">(</span><span style="--shiki-light:#001080;--shiki-dark:#BFBDB6;">$a</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">) </span><span style="--shiki-light:#000000;--shiki-dark:#F29668;">==</span><span style="--shiki-light:#795E26;--shiki-dark:#F07178;"> md5</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">(</span><span style="--shiki-light:#001080;--shiki-dark:#BFBDB6;">$b</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">)){</span><span style="--shiki-light:#000000;--shiki-dark:#F29668;">...</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这里的核心矛盾是“两个不同变量的 MD5 值弱比较相等”。PHP 在处理弱比较（<code>==</code>）时会进行<strong>类型转换</strong>，若比较双方是字符串且以 <code>0e</code> 开头，会被当作科学计数法的 <code>0</code> 处理。因此，只要找到两个不同的字符串，其 MD5 哈希值均以 <code>0e</code> 开头，即可满足条件。</p><p><strong>实战 payload</strong>：<code>?a=QNKCDZO&amp;b=240610708</code></p><ul><li><code>md5(&quot;QNKCDZO&quot;)</code> 的结果为 <code>0e830400451993494058024219903391</code></li><li><code>md5(&quot;240610708&quot;)</code> 的结果为 <code>0e462097431906509019562988736854</code> 两者在弱比较中均被解析为 <code>0</code>，因此 <code>md5($a) == md5($b)</code> 成立，而 <code>$a</code> 与 <code>$b</code> 数值不同，满足 <code>$a != $b</code> 的条件。</li></ul><p><strong>关键原理</strong>：PHP 弱比较会将 <code>0e</code> 开头的哈希字符串识别为科学计数法的 <code>0</code>，因此只要哈希值前两位是 <code>0e</code>，后续字符为数字，即可实现不同字符串的 MD5 弱比较相等。</p><h4 id="第二层-数组传递的强比较绕过" tabindex="-1"><a class="header-anchor" href="#第二层-数组传递的强比较绕过"><span>第二层：数组传递的强比较绕过</span></a></h4><p>通过第一层后，题目进入第二层验证，代码如下：</p><div class="language-php line-numbers-mode" data-highlighter="shiki" data-ext="php" style="--shiki-light:#000000;--shiki-dark:#bfbdb6;--shiki-light-bg:#FFFFFF;--shiki-dark-bg:#0b0e14;"><pre class="shiki shiki-themes light-plus ayu-dark vp-code"><code class="language-php"><span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#FF8F40;">if</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">(</span><span style="--shiki-light:#001080;--shiki-dark:#BFBDB6;">$_POST</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">[</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;">&#39;param1&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">]</span><span style="--shiki-light:#000000;--shiki-dark:#F29668;">!==</span><span style="--shiki-light:#001080;--shiki-dark:#BFBDB6;">$_POST</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">[</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;">&#39;param2&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">] </span><span style="--shiki-light:#000000;--shiki-dark:#F29668;">&amp;&amp;</span><span style="--shiki-light:#795E26;--shiki-dark:#F07178;"> md5</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">(</span><span style="--shiki-light:#001080;--shiki-dark:#BFBDB6;">$_POST</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">[</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;">&#39;param1&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">])</span><span style="--shiki-light:#000000;--shiki-dark:#F29668;">===</span><span style="--shiki-light:#795E26;--shiki-dark:#F07178;">md5</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">(</span><span style="--shiki-light:#001080;--shiki-dark:#BFBDB6;">$_POST</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">[</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;">&#39;param2&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">])){</span><span style="--shiki-light:#000000;--shiki-dark:#F29668;">...</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这里升级为<strong>强比较（<code>===</code>）</strong>，要求 MD5 值完全一致，且 <code>param1</code> 与 <code>param2</code> 严格不同。此时需利用 PHP 的另一个特性：<strong>当 <code>md5()</code> 函数接收数组作为参数时，会返回 <code>NULL</code></strong>。因此，只要让 <code>param1</code> 和 <code>param2</code> 均为数组（且内容不同），即可使两者的 MD5 值都为 <code>NULL</code>，满足 <code>NULL === NULL</code> 的强比较条件。</p><p><strong>实战 payload</strong>：<code>param1[]=1&amp;param2[]=2</code>（通过 POST 提交）</p><ul><li><code>param1[]=1</code> 和 <code>param2[]=2</code> 是两个不同的数组，满足 <code>param1!==param2</code></li><li><code>md5(param1)</code> 和 <code>md5(param2)</code> 均返回 <code>NULL</code>，因此 <code>md5(param1)===md5(param2)</code> 成立</li></ul><p><strong>注意事项</strong>：数组绕过仅适用于 PHP 环境，其他语言（如 Python、Java）的哈希函数处理数组时可能抛出异常而非返回 <code>NULL</code>，需根据具体场景判断。</p><h4 id="两层绕过的组合应用" tabindex="-1"><a class="header-anchor" href="#两层绕过的组合应用"><span>两层绕过的组合应用</span></a></h4><p>解题时需按顺序突破两层验证：</p><ol><li>先用 GET 方法提交 <code>?a=QNKCDZO&amp;b=240610708</code> 绕过第一层弱比较；</li><li>再用 POST 方法提交 <code>param1[]=1&amp;param2[]=2</code> 绕过第二层强比较。</li></ol><p>通过 Burp Suite 抓包可清晰观察到请求与响应过程：第一层请求后服务器返回第二层验证页面，第二层提交数组参数后成功获取 flag。这种“组合拳”式的漏洞利用，体现了 CTF 题目对细节知识点的综合考察。</p><h3 id="cgctf-web-md5-collision-0e弱比较绕过" tabindex="-1"><a class="header-anchor" href="#cgctf-web-md5-collision-0e弱比较绕过"><span>CGCTF-Web-md5 collision：0e弱比较绕过</span></a></h3><p>在CTF Web题目中，MD5弱比较漏洞是一种常见且极具迷惑性的考点。以典型题目代码为例，我们经常会遇到类似这样的逻辑限制：</p><div class="language-php line-numbers-mode" data-highlighter="shiki" data-ext="php" style="--shiki-light:#000000;--shiki-dark:#bfbdb6;--shiki-light-bg:#FFFFFF;--shiki-dark-bg:#0b0e14;"><pre class="shiki shiki-themes light-plus ayu-dark vp-code"><code class="language-php"><span class="line"><span style="--shiki-light:#001080;--shiki-dark:#BFBDB6;">$md51</span><span style="--shiki-light:#000000;--shiki-dark:#F29668;"> =</span><span style="--shiki-light:#795E26;--shiki-dark:#F07178;"> md5</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">(</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;">&#39;QNKCDZO&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">)</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6B3;">;</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#BFBDB6;">$a</span><span style="--shiki-light:#000000;--shiki-dark:#F29668;"> =</span><span style="--shiki-light:#000000;--shiki-dark:#F29668;"> @</span><span style="--shiki-light:#001080;--shiki-dark:#BFBDB6;">$_GET</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">[</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;">&#39;a&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">]</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6B3;">;</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#BFBDB6;">$md52</span><span style="--shiki-light:#000000;--shiki-dark:#F29668;"> =</span><span style="--shiki-light:#000000;--shiki-dark:#F29668;"> @</span><span style="--shiki-light:#795E26;--shiki-dark:#F07178;">md5</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">(</span><span style="--shiki-light:#001080;--shiki-dark:#BFBDB6;">$a</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">)</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6B3;">;</span></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#FF8F40;">if</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">(</span><span style="--shiki-light:#795E26;--shiki-dark:#F07178;">isset</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">(</span><span style="--shiki-light:#001080;--shiki-dark:#BFBDB6;">$a</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">)){</span></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#FF8F40;">if</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;"> (</span><span style="--shiki-light:#001080;--shiki-dark:#BFBDB6;">$a</span><span style="--shiki-light:#000000;--shiki-dark:#F29668;"> !=</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;"> &#39;QNKCDZO&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#F29668;"> &amp;&amp;</span><span style="--shiki-light:#001080;--shiki-dark:#BFBDB6;"> $md51</span><span style="--shiki-light:#000000;--shiki-dark:#F29668;"> ==</span><span style="--shiki-light:#001080;--shiki-dark:#BFBDB6;"> $md52</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">) {</span></span>
<span class="line"><span style="--shiki-light:#795E26;--shiki-dark:#F07178;">echo</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;"> &quot;nctf{*****************}&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6B3;">;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">} </span><span style="--shiki-light:#AF00DB;--shiki-dark:#FF8F40;">else</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;"> {</span></span>
<span class="line"><span style="--shiki-light:#795E26;--shiki-dark:#F07178;">echo</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;"> &quot;false!!!&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6B3;">;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">}</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">}</span></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#FF8F40;">else</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">{</span></span>
<span class="line"><span style="--shiki-light:#795E26;--shiki-dark:#F07178;">echo</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;"> &quot;please input a&quot;</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6B3;">;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码要求传入的参数 <code>a</code> 必须满足两个条件：<strong>值不等于字符串 &quot;QNKCDZO&quot;</strong>，同时 <strong><code>md5(a)</code> 的结果与 <code>md5(&quot;QNKCDZO&quot;)</code> 弱比较相等</strong>。这就需要我们深入理解PHP中弱比较（<code>==</code>）的特性。</p><h4 id="关键字符串的md5值对比" tabindex="-1"><a class="header-anchor" href="#关键字符串的md5值对比"><span>关键字符串的MD5值对比</span></a></h4><p>首先，我们需要明确两个核心字符串的MD5哈希结果：</p><table><thead><tr><th>原始字符串</th><th>MD5哈希值</th><th>哈希值特征</th></tr></thead><tbody><tr><td>QNKCDZO</td><td>0e830400451993494058024219903391</td><td>以 <code>0e</code> 开头，后续为纯数字</td></tr><tr><td>240610708</td><td>0e462097431906509019562988736854</td><td>以 <code>0e</code> 开头，后续为纯数字</td></tr></tbody></table><p>从表格中可以看出，尽管两个原始字符串完全不同，但它们的MD5哈希值都具有 <strong><code>0e</code> 开头且后续字符均为数字</strong> 的特点。这正是实现弱比较绕过的关键。</p><h4 id="php弱比较的底层逻辑验证" tabindex="-1"><a class="header-anchor" href="#php弱比较的底层逻辑验证"><span>PHP弱比较的底层逻辑验证</span></a></h4><p>我们通过PHP代码直接验证两者的比较结果：</p><div class="language-php line-numbers-mode" data-highlighter="shiki" data-ext="php" style="--shiki-light:#000000;--shiki-dark:#bfbdb6;--shiki-light-bg:#FFFFFF;--shiki-dark-bg:#0b0e14;"><pre class="shiki shiki-themes light-plus ayu-dark vp-code"><code class="language-php"><span class="line"><span style="--shiki-light:#795E26;--shiki-dark:#F07178;">var_dump</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">(</span><span style="--shiki-light:#795E26;--shiki-dark:#F07178;">md5</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">(</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;">&#39;240610708&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">) </span><span style="--shiki-light:#000000;--shiki-dark:#F29668;">==</span><span style="--shiki-light:#795E26;--shiki-dark:#F07178;"> md5</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">(</span><span style="--shiki-light:#A31515;--shiki-dark:#AAD94C;">&#39;QNKCDZO&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6;">))</span><span style="--shiki-light:#000000;--shiki-dark:#BFBDB6B3;">;</span><span style="--shiki-light:#008000;--shiki-light-font-style:inherit;--shiki-dark:#ACB6BF8C;--shiki-dark-font-style:italic;"> // 输出：bool(true)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>为什么会出现这种结果？这涉及到PHP在处理弱比较（<code>==</code>）时的 <strong>类型转换机制</strong>。当比较两个字符串时，PHP会尝试将它们转换为数值类型后再比较。对于以 <code>0e</code> 开头的字符串，PHP会将其识别为 <strong>科学计数法表示的数字</strong>，即 <code>0 × 10^xxx</code>，结果恒为 <strong>0</strong>。因此，上述两个MD5哈希值在弱比较时都会被解析为0，导致 <code>==</code> 判断成立。</p><p><strong>漏洞本质</strong>：当字符串以 <code>0e</code> 开头且后续字符均为数字时，PHP在弱比较中会将其强制转换为科学计数法表示的0。利用这一特性，可构造不同原始字符串但MD5哈希值满足该格式的 payload，绕过 <code>$md51 == $md52</code> 的限制。</p><h4 id="实战绕过与payload构造" tabindex="-1"><a class="header-anchor" href="#实战绕过与payload构造"><span>实战绕过与Payload构造</span></a></h4><p>回到题目代码，由于 <code>$a != &#39;QNKCDZO&#39;</code> 的限制，我们不能直接传入 <code>QNKCDZO</code> 作为参数。但可以使用 <code>240610708</code> 作为替代，其MD5哈希值同样满足 <code>0e</code> 开头的条件。因此，构造如下Payload即可获取flag：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#000000;--shiki-dark:#bfbdb6;--shiki-light-bg:#FFFFFF;--shiki-dark-bg:#0b0e14;"><pre class="shiki shiki-themes light-plus ayu-dark vp-code"><code class="language-"><span class="line"><span>?a=240610708</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>除了 <code>240610708</code>，常见的 <code>0e</code> 开头MD5字符串还包括 <code>s878926199a</code>（MD5：0e545993274517709034328855841020）、<code>s155964671a</code>（MD5：0e342768416822451524974117254469）等，这些都可作为弱比较绕过的备选 payload。</p><p>通过这个案例可以看出，理解编程语言的底层类型转换规则，往往是解决CTF中哈希比较类题目的关键。在实际攻防中，不仅要掌握已知的 <code>0e</code> 字符串列表，更要理解其背后的原理，才能应对更复杂的变异场景。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><h3 id="核心学习心得-从漏洞本质到防御关键" tabindex="-1"><a class="header-anchor" href="#核心学习心得-从漏洞本质到防御关键"><span>核心学习心得：从漏洞本质到防御关键</span></a></h3><p>经过对 PHP MD5 漏洞的系统梳理，可提炼出三点核心认知：</p><ul><li><strong>漏洞本质</strong>：源于 PHP 弱类型比较机制（如 <code>==</code> 触发的类型转换）与 MD5 算法自身缺陷（碰撞脆弱性、哈希值解析特性）的叠加效应，典型表现为 0e 科学计数法绕过、数组参数处理异常等场景[<a href="https://www.oryoy.com/news/po-jie-php-mi-ma-jia-mi-md5-bei-hou-de-an-quan-feng-xian-yu-fang-hu-zhi-dao.html" target="_blank" rel="noopener noreferrer">1</a>][<a href="https://blog.csdn.net/weixin_41905135/article/details/151580567" target="_blank" rel="noopener noreferrer">13</a>]。</li><li><strong>绕过核心</strong>：实战中需针对不同机制选择策略——弱比较场景构造以 <code>0e</code> 开头的哈希字符串（如 <code>QNKCDZO</code> 的 MD5 值为 <code>0e830400451993494058024219903391</code>），数组处理缺陷可注入 <code>array()</code> 参数绕过 <code>md5()</code> 函数，算法碰撞则需生成特定二进制字符串（如 <code>d131dd02c5e6eec4</code> 开头的碰撞样本）[<a href="https://blog.csdn.net/qq_19980431/article/details/83018856" target="_blank" rel="noopener noreferrer">7</a>][<a href="https://www.oryoy.com/news/jie-mi-php-md5-jia-mi-xing-neng-you-hua-yu-an-quan-kao-liang.html" target="_blank" rel="noopener noreferrer">14</a>]。</li><li><strong>防御关键</strong>：核心在于切断漏洞利用路径——开发者需用强类型比较（<code>===</code>）替代弱比较，用 <code>password_hash()</code>/<code>password_verify()</code> 替代 MD5 存储密码；CTF 选手则需敏锐识别漏洞特征，如代码中 <code>md5($a) == md5($b)</code>、数组参数接收点、<code>raw_output=true</code> 等关键信号[<a href="https://wenku.csdn.net/answer/1f5kbyki0b" target="_blank" rel="noopener noreferrer">15</a>][<a href="https://blog.csdn.net/m0_73812072/article/details/151645619" target="_blank" rel="noopener noreferrer">16</a>]。</li></ul><p><strong>思维导图核心对应关系</strong>： • 弱类型比较 → 0e 科学计数法绕过、哈希值类型转换 • 数组处理机制 → <code>array()</code> 参数注入、<code>md5([]) 返回 NULL</code> • 算法缺陷 → 碰撞字符串生成、二进制输出注入 • 防御措施 → 强比较（<code>===</code>）、安全哈希函数（bcrypt/Argon2）、输入过滤</p><h3 id="防御实践-开发者与-ctf-选手的双向视角" tabindex="-1"><a class="header-anchor" href="#防御实践-开发者与-ctf-选手的双向视角"><span>防御实践：开发者与 CTF 选手的双向视角</span></a></h3><h4 id="开发者视角-构建安全编码规范" tabindex="-1"><a class="header-anchor" href="#开发者视角-构建安全编码规范"><span>开发者视角：构建安全编码规范</span></a></h4><p>现代应用需彻底摒弃 MD5 用于敏感场景（如密码存储、数据校验），转而采用 bcrypt、Argon2 等带盐哈希算法，并通过 PHP 内置函数 <code>password_hash()</code> 实现标准化加密流程[<a href="https://www.oryoy.com/news/jie-mi-php-md5-jia-mi-an-quan-lou-dong-yu-fang-fan-zhi-dao.html" target="_blank" rel="noopener noreferrer">17</a>][<a href="https://www.php.cn/faq/566897.html" target="_blank" rel="noopener noreferrer">18</a>]。代码层面需严格执行：</p><ul><li>哈希比较必须使用 <code>===</code> 或 <code>hash_equals()</code> 函数，避免 <code>==</code> 触发的隐性类型转换；</li><li>对用户输入进行严格过滤，禁止直接将数组参数传入 <code>md5()</code> 函数；</li><li>禁用 <code>raw_output=true</code> 等二进制输出场景，防止注入攻击[<a href="https://blog.51cto.com/u_15854462/11803182" target="_blank" rel="noopener noreferrer">6</a>][<a href="https://blog.csdn.net/weixin_33603105/article/details/115967597" target="_blank" rel="noopener noreferrer">19</a>]。</li></ul><h4 id="ctf-选手视角-漏洞识别与利用策略" tabindex="-1"><a class="header-anchor" href="#ctf-选手视角-漏洞识别与利用策略"><span>CTF 选手视角：漏洞识别与利用策略</span></a></h4><p>解题时需重点关注三类特征代码：</p><ul><li><strong>弱比较标记</strong>：<code>if (md5($a) == md5($b))</code> 或 <code>md5($x) == &#39;0e123456&#39;</code>，优先尝试构造 0e 字符串；</li><li><strong>数组参数入口</strong>：如 <code>$_GET[&#39;param&#39;]</code> 未做类型校验时，传入 <code>param[]=1</code> 触发 <code>md5(array()) === NULL</code> 绕过；</li><li><strong>复合场景信号</strong>：代码中同时出现 <code>md5()</code> 与文件操作（如 <code>include</code>）、命令执行（如 <code>system</code>）函数时，需警惕哈希注入与其他漏洞的联动利用[<a href="https://www.oryoy.com/news/jie-mi-php-md5-jia-mi-xing-neng-you-hua-yu-an-quan-kao-liang.html" target="_blank" rel="noopener noreferrer">14</a>][<a href="https://blog.csdn.net/lyj20010728/article/details/116779357" target="_blank" rel="noopener noreferrer">20</a>]。</li></ul><h3 id="未来趋势-新题型与复合漏洞的融合演进" tabindex="-1"><a class="header-anchor" href="#未来趋势-新题型与复合漏洞的融合演进"><span>未来趋势：新题型与复合漏洞的融合演进</span></a></h3><p>随着 PHP 版本迭代与安全实践升级，简单的 MD5 绕过题目逐渐减少，但漏洞利用呈现<strong>技术深化</strong>与<strong>场景复合</strong>两大趋势：</p><h4 id="_1-新型攻击技术兴起" tabindex="-1"><a class="header-anchor" href="#_1-新型攻击技术兴起"><span>1. 新型攻击技术兴起</span></a></h4><ul><li><strong>双 MD5 加盐碰撞</strong>：题目常设计 <code>md5(md5($str) . &#39;SALT&#39;)</code> 等嵌套哈希逻辑，需通过爆破或碰撞生成满足双重哈希条件的字符串，对算力与算法理解提出更高要求[<a href="https://www.oryoy.com/news/jie-mi-php-md5-jia-mi-an-quan-lou-dong-yu-fang-fan-zhi-dao.html" target="_blank" rel="noopener noreferrer">17</a>]；</li><li><strong>伪随机数依赖风险</strong>：部分题目通过 <code>mt_srand()</code> 种子生成哈希值，选手可利用种子预测工具（如 <code>php_mt_seed</code>）反推随机序列，构造可控 MD5 结果[<a href="https://www.oryoy.com/news/jie-mi-php-md5-jia-mi-xing-neng-you-hua-yu-an-quan-kao-liang.html" target="_blank" rel="noopener noreferrer">14</a>]。</li></ul><h4 id="_2-跨漏洞类型融合" tabindex="-1"><a class="header-anchor" href="#_2-跨漏洞类型融合"><span>2. 跨漏洞类型融合</span></a></h4><p>CTF 中 MD5 漏洞正与其他高危漏洞深度结合，典型组合包括：</p><ul><li><strong>MD5 注入 + 文件包含</strong>：通过构造哈希值注入文件路径，如 <code>md5($file) == &#39;xxx&#39;</code> 绕过文件包含限制；</li><li><strong>弱比较 + 命令执行</strong>：利用 <code>==</code> 绕过条件判断后，触发 <code>eval(md5($code))</code> 等危险函数执行代码[<a href="https://www.oryoy.com/news/po-jie-php-mi-ma-jia-mi-md5-bei-hou-de-an-quan-feng-xian-yu-fang-hu-zhi-dao.html" target="_blank" rel="noopener noreferrer">1</a>][<a href="https://blog.csdn.net/lyj20010728/article/details/116779357" target="_blank" rel="noopener noreferrer">20</a>]。</li></ul><h3 id="总结-从-ctf-到实战的能力迁移" tabindex="-1"><a class="header-anchor" href="#总结-从-ctf-到实战的能力迁移"><span>总结：从 CTF 到实战的能力迁移</span></a></h3><p>尽管 MD5 在现代应用中已逐步被淘汰，但其漏洞所反映的<strong>弱类型语言特性</strong>、<strong>哈希算法安全边界</strong>等问题，仍是安全领域的核心命题。对 CTF 选手而言，掌握 MD5 漏洞不仅是解题刚需，更是理解 PHP 底层机制、提升代码审计能力的关键路径；对开发者而言，需以历史漏洞为鉴，建立“算法选型 - 编码规范 - 输入验证”三位一体的安全体系，方能在攻防对抗中占据主动。未来，随着 SHA-3、Argon2 等算法的普及，漏洞形态可能变化，但“理解原理 - 识别特征 - 精准防御”的思维框架将始终适用。</p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h2><p>以下为学习 PHP MD5 漏洞解析与 CTF 实战所需的核心资源，按类别整理并标注来源与时间，便于追溯与深入研究：</p><h3 id="ctf题目链接" tabindex="-1"><a class="header-anchor" href="#ctf题目链接"><span>CTF题目链接</span></a></h3><ol><li>Bugku MD5碰撞实战题目（https://www.bugku.com/thread-1061-1-1.html，Bugku，2024-03）</li><li>CTF Writeups 平台 MD5漏洞专题（https://github.com/topics/ctf-writeups?o=desc&amp;s=updated，GitHub，2025-09更新）</li></ol><h3 id="技术解析博客" tabindex="-1"><a class="header-anchor" href="#技术解析博客"><span>技术解析博客</span></a></h3><ol><li>CSDN博客《PHP MD5漏洞原理与CTF实战案例》（https://blog.csdn.net/ec_carrot/article/details/109525162，CSDN，2020-10）</li><li>博客园《CTF中PHP MD5绕过技巧全解析》（https://www.cnblogs.com/ALe3/p/19012075，博客园，2024-01）</li><li>ORYOY新闻《解密PHP MD5加密安全漏洞与防范指南》（https://www.oryoy.com/news/jie-mi-php-md5-jia-mi-an-quan-lou-dong-yu-fang-fan-zhi-dao.html，ORYOY，2023-06）</li></ol><h3 id="工具资源" tabindex="-1"><a class="header-anchor" href="#工具资源"><span>工具资源</span></a></h3><ol><li>GitHub MD5碰撞生成工具集合（https://github.com/topics/md5-collisions，GitHub，2025-09更新）</li><li>Brandon Elliott MD5哈希在线分析工具（https://brandon-t-elliott.github.io/md5，个人技术博客，2024-11）</li></ol><h3 id="官方文档" tabindex="-1"><a class="header-anchor" href="#官方文档"><span>官方文档</span></a></h3><ol><li>PHP官方md5_file函数文档（https://www.php.net/manual/ja/function.md5-file.php，PHP.net，2025-03）</li><li>PHP RFC MD5函数弃用提案（https://wiki.php.net/rfc/release-md5-deprecation，PHP Wiki，2024-06）</li><li>PHP中文网MD5安全问题FAQ（https://www.php.cn/faq/566897.html，PHP中文网，2023-12）</li></ol><p><strong>使用建议</strong>：CTF题目链接可直接实操练习，技术解析博客建议结合题目复现阅读，工具资源中的GitHub仓库需配合Python环境使用，官方文档重点关注PHP版本对MD5函数的安全性更新。</p>`,141)])])}const p=i(t,[["render",h]]),r=JSON.parse(`{"path":"/article/9w9s6ro0/","title":"CTF中的PHP MD5漏洞解析与实战技巧","lang":"zh-CN","frontmatter":{"title":"CTF中的PHP MD5漏洞解析与实战技巧","createTime":"2025/09/18 10:25:40","permalink":"/article/9w9s6ro0/","tags":["CTF","PHP"],"description":"引言 在 CTF 竞赛的 Web 安全赛道上，有一个漏洞类型常年占据\\"常驻嘉宾\\"席位——PHP 环境下的 MD5 函数漏洞。无论是新手入门的基础题，还是进阶挑战的综合题，总能看到它的身影。这背后究竟藏着怎样的原因？ 数据透视：CTF 比赛中 Web 题型占比常年超 40%，而哈希相关题目在其中占比达 15%，PHP MD5 漏洞正是这部分题目的核心考点...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"CTF中的PHP MD5漏洞解析与实战技巧\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-09-19T03:23:43.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://gaifagafin.top/article/9w9s6ro0/"}],["meta",{"property":"og:site_name","content":"Gaifa Gafin's Blog"}],["meta",{"property":"og:title","content":"CTF中的PHP MD5漏洞解析与实战技巧"}],["meta",{"property":"og:description","content":"引言 在 CTF 竞赛的 Web 安全赛道上，有一个漏洞类型常年占据\\"常驻嘉宾\\"席位——PHP 环境下的 MD5 函数漏洞。无论是新手入门的基础题，还是进阶挑战的综合题，总能看到它的身影。这背后究竟藏着怎样的原因？ 数据透视：CTF 比赛中 Web 题型占比常年超 40%，而哈希相关题目在其中占比达 15%，PHP MD5 漏洞正是这部分题目的核心考点..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-19T03:23:43.000Z"}],["meta",{"property":"article:tag","content":"PHP"}],["meta",{"property":"article:tag","content":"CTF"}],["meta",{"property":"article:modified_time","content":"2025-09-19T03:23:43.000Z"}]]},"readingTime":{"minutes":21.46,"words":6438},"git":{"createdTime":1758252223000,"updatedTime":1758252223000,"contributors":[{"name":"gaifagafin","username":"gaifagafin","email":"1454991831@qq.com","commits":1,"avatar":"https://avatars.githubusercontent.com/gaifagafin?v=4","url":"https://github.com/gaifagafin"}]},"autoDesc":true,"filePathRelative":"CTF/notes/CTF中的PHP MD5漏洞解析与实战技巧.md","headers":[],"categoryList":[{"id":"59db91","sort":10002,"name":"CTF"},{"id":"a1b781","sort":10003,"name":"notes"}]}`);export{p as comp,r as data};
